##This function implements the initial part of the Covid-19 deconvolution model.
##The goal is to construct the design matrix required for estimation
##the design matrices needed to estimate the daily infection curve f(t) 
## Observed deaths t_death and infection-to-death distribution π(d) are given.
## The model assumes a Poisson likelihood
## The infection curve f(t) is assumed to be smooth, and represented using a B-spline.
## The function performs the following:
## 1. Defines the infection-to-death probability distribution π(d)
##    for durations d = 1:80 days using a lognormal distribution
## 2. Constructs the B-spline basis matrix tilde_X for f(t):
##    K + 4 evenly spaced knots are used.
##    The middle K-2 knots cover the interval over which f(t) is evaluated.
## 3. Constructs the design matrix X for μ_i:
##    Each row corresponds to one observed death day t_i.
##    Each column corresponds to a B-spline coefficient β_k.
##    Each μ_i is computed as a weighted sum of the basis functions
##    evaluated at the infection times t_i - j, weighted by π(j).
## 4. Computes the smoothing penalty matrix S:
##    S = t(D) %*% D, where D is the second-difference matrix.
##    Penalizes roughness in β, encouraging smooth f(t).

create_design_matrices <- function(t_death, K = 80) {
# Define infection-to-death probability distribution
d <- 1:80
edur <- 3.151
sdur <- 0.469
pd <- dlnorm(d, edur, sdur)
pd <- pd / sum(pd)  # Normalize to probability distribution
  
n <- length(t_death)  # Number of death observations
  
# Determine time range for f(t)
# f(t) needs to cover infections that could lead to observed deaths
t_min <- min(t_death) - 80  # Go back maximum duration before first death
t_max <- max(t_death)       # Up to last death day
t_f <- t_min:t_max          # All time points for infection function

# Create B-spline basis matrix tilde_X
# Create K+4 evenly spaced knots covering the range of f(t)
knots <- seq(t_min, t_max, length.out = K + 4)
  
# Use splineDesign to create B-spline basis matrix
tilde_X <- splineDesign(knots = knots, x = t_f, outer.ok = TRUE)

# Create design matrix X for death model
# Create matrix of all possible (i,j) combinations
i_vec <- rep(1:n, each = 80)
j_vec <- rep(1:80, times = n) 
  
# Only keep valid durations j for each death day i
valid <- j_vec <= pmin(29 + i_vec, 80)
i_vec <- i_vec[valid]
j_vec <- j_vec[valid]
  
# Corresponding infection times
infection_times <- t_death[i_vec] - j_vec
  
# Indices in t_f
t_f_idx <- infection_times - t_min + 1  # Shift to 1-based index
valid_idx <- t_f_idx >= 1 & t_f_idx <= length(t_f)

# Only keep indices that are valid
i_vec <- i_vec[valid_idx]
j_vec <- j_vec[valid_idx]
t_f_idx <- t_f_idx[valid_idx]
  
# Build sparse matrix X
# Each row is a death observation
# Each column is a B-spline coefficient
# Multiply the corresponding tilde_X row by the infection-to-death probability
X <- sparseMatrix(
  i = rep(i_vec, each = K),
  j = rep(1:K, times = length(i_vec)),
  x = as.vector(tilde_X[t_f_idx, ] * pd[j_vec]), # Weighted contribution
  dims = c(n, K)
)
  
# Construct penalty matrix S for smoothing
D <- diff(diag(K), differences = 2)
S <- crossprod(D)
return(list(
  tilde_X = tilde_X,
  X = X,
  S = S,
  t_f = t_f,
  pd = pd
))
}


##This function computes the penalized negative log-likelihood and its gradient 
##for the Poisson deconvolution model used to estimate the daily infection curve f(t).
##The model assumes that observed daily deaths y_i follow a Poisson distribution
##A smoothness penalty on beta is included to control overfitting.
##The functions are designed for use with 'optim' for numerical optimization.

penalized_nll <- function(gamma, y, X, S, lambda) {
  beta <- exp(gamma)  # ensure positivity of beta
  mu <- as.vector(X %*% beta)   
  mu[mu <= 1e-12] <- 1e-12   # avoid log(0)
  
  # negative log-likelihood
  nll <- sum(mu - y * log(mu))
  
  # add smoothness penalty term
  penalty <- 0.5 * lambda * crossprod(beta, S %*% beta)
  return(nll + penalty)
}


penalized_grad <- function(gamma, y, X, S, lambda) {
  beta <- exp(gamma)
  mu <- as.vector(X %*% beta)
  mu[mu <= 1e-12] <- 1e-12
  
  # gradient of log-likelihood part
  grad_ll <- t(X) %*% (1 - y / mu)
  
  # gradient of penalty part
  grad_pen <- lambda * (S %*% beta)
  
  # chain rule
  grad <- as.vector(beta * (grad_ll + grad_pen))
  return(grad)
}
